<pre class='metadata'>
Title: Web Audio API performance and debugging notes
Status: ED
ED: https://padenot.github.io/web-audio-perf
shortname: web-audio-perf
Level:1 - an integer for the spec's level. If you're unsure, just put "1".
Editor: Paul Adenot <padenot@mozilla.com>
Abstract: These notes present the Web Audio API from a performance and debugging point of view, outlining some differences between implementation.
group: plain
Boilerplate: omit property-index logo copyright references property-index
</pre>
<section>
  <h2>Introduction</h2>
  In this tutorial, we will look at two different aspects of working with the Web
  Audio API.

  First, we’ll have a look into the performance characteristics of the different
  <code>AudioNode</code>s available, their performance profile, overall CPU and memory cost,
  and strategies to use resources (CPU, memory) more efficiently. For example,
  we’ll learn how to look into the source code of different implementations, and
  determine the algorithm and techniques used in each browser, to make better
  choices when developing applications.

  We’ll then look into ways to make processing lighter, while still retaining the
  essence of the application, for example to make a "degraded" mode for mobile.
  We’ll use techniques such as substituting rendering methods to trade fidelity
  against CPU load, pre-baking assets, minimizing resampling.

  Throughout the workshop, we’ll use tools and techniques to debug audio problems,
  both using in-browser tools, or JavaScript code designed to inspect static and
  dynamic audio graphs and related Web Audio API objects.
</section>
<section>
  <h2>Optimizing Web Audio API applications</h2>
  <h3><code>AudioNode</code>s characteristics</h3>
  This section explains the characteristics of each of the
  <code>AudioNode</code> that are available in the Web Audio API, from four
  angles.

  <ul>
  <li>
  CPU, that is the temporal complexity of the processing algorithm;
  </li>
  <li>
  Memory, whether node needs to keep buffers around, or needs internal memory
  for processing;
  </li>
  <li>
  Latency, whether the processing induces a delay in the processing chain. If
  this section is not present, the node does not add latency;
  </li>
  <li>
  Tail, whether you can have a non-zero output when the
  input is continuously silent (for example because the audio source has
  stopped). If this section is not present, the node does not have a tail.
  </li>
  </ul>

  <h4> AudioBufferSourceNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>The <code>AudioBufferSourceNode</code> automatically resamples its
    <code>buffer</code> attribute to the sample-rate of the <code>AudioContext</code>. Resampling is
    done differently in different browsers. Edge, Blink and Webkit based browser
    use linear resampling, that is cheap, has no latency, but has low quality.
    Gecko based browser use a more expensive but higher quality technique, that
    introduces some latency.</dd>
    <dt>Memory</dt>
    <dd>The <code>AudioBufferSourceNode</code> reads sample from an
    <code>AudioBuffer</code> that can be shared between multiple nodes. The
    resampler used in Gecko uses some memory for the filter, but nothing major.</dd>
  </dl>
  <h4> ScriptProcessorNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>On Gecko-based browsers, this node uses a message queue to send buffers
    back and forth between the main thread and the rendering thread. On other
    browsers, buffer ping-ponging is used. This means that the former is more
    reliable against dropouts, but can have a higher latency (depending on the
    main thread event loop load), whereas the latter drops
    out more easily, but has fixed latency.</dd>
    <dt>Memory</dt>
    <dd>
      Buffers have to be allocated to move audio back and forth between threads.
    Since Gecko uses a buffer queue, more memory can be used.
    </dd>
    <dt>Latency</dt>
    <dd> The latency is specified when creating the node. If Gecko has trouble
    keeping up, the latency will increase, up to a point where audio will start
    to drop.</dd>
  </dl>
  <h4> AnalyserNode </h4>
  <dl>
  <dt>CPU</dt>
  <dd>This node can give frequency domain data, using a Fast Fourier Transform
  algorithm, that is expensive to compute. The higher the buffer size, the more
  expensive the computing is. <code>byte</code> version of the analysis methods
  are not cheaper than <code>float</code> alternative, they are provided for
  convenience: the <code>byte</code> version are computed from the
  <code>float</code> version, using simple quantization to 2^8 values.</dd>
  <dt>Memory</dt>
  <dd>Fast Fourier Transform algorithms use internal memory for processing.
  Different platforms and browsers have different algorithms, so it's hard to
  quantify exactly how much memory is going to be used. Additionally, some
  memory is going to be used for the <code>AudioBuffer</code> passed in to the
  analysis methods. </dd>
  <dt>Latency</dt>
  <dd>Because of the windowing function there can be some perceived latency in
  this node, but windowing can be disabled by setting it to 0.</dd>
  <dt>Tail</dt>
  <dd>Because of the windowing function there can be a tail with
  this node, but windowing can be disabled by setting it to 0.</dd>
</dl>
  <h4> GainNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>Gecko-based browsers, the gain is always applied lazily, and folded in
    before processing that require to touch the samples, or before send the
    rendered buffer back to the operating system, so <code>GainNode</code> with
    a fixed gain are essentially free. In other engines, the gain is applied to
    the input buffer as it's received. When automating the gain using
    <code>AudioParam</code> methods, the gain is applied to the buffer in all
    browsers. </dd>
    <dt>Memory</dt>
    <dd>A <code>GainNode</code> is stateless and has therefore no associated
    memory cost.</dd>
  </dl>
  <h4> DelayNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>This node essentially copies input data into a buffer, and reads from this
    buffer at a different location to compute its output buffer.</dd>
    <dt> Memory</dt>
    <dd> The memory cost is a function of the number of input and output
    channels and the length of the delay line. </dd>
    <dt>Latency</dt>
    <dd>Obviously this node introduces latency, but no more than the latency set
    by its parameter</dd>
    <dt>Tail</dt>
    <dd>This node is being kept around (not collected) until it has finished
    reading and has output all of its internal buffer.</dd>
  </dl>
  <h4> BiquadFilterNode </h4>
  <dl>
  <dt>CPU</dt>
    <dd>Biquad filters are relatively cheap (five multiplication and four
    additions per sample).</dd>
  <dt>Memory</dt>
  <dd>Very cheap, four float for the memory of the filter.</dd>
  <dt>Latency</dt>
  <dd>Exactly two frames of latency, due to how the filter works.</dd>
  <dt>Tail</dt>
  <dd>Variable tail, depending on the filter setting (in particular the
  resonance).</dd>
 </dl>
 <h4> IIRFilterNode </h4>
 <dl>
   <dt>CPU</dt>
   <dd>Similarly to the biquad filter, they are rather cheap. The complexity
   depends on the number of coefficients, that is set at construction.</dd>
   <dt>Memory</dt>
   <dd>Again, the memory usage depends on the number of coefficients, but is
   overall very small (a couple floats per coefficients).</dd>
   <dt>Latency</dt>
   <dd>A frame per coefficient.</dd>
   <dt>Tail</dt>
   <dd>Variable, depending on the value of the coefficients.</dd>
  </dl>
  <h4> WaveShaperNode </h4>
  <dl>
  <dt>CPU</dt>
  <dd>The computational complexity depends on the oversampling. If no
  oversampling is used, a sample is read in the wave table, using linear
  interpolation, which is a cheap process in itself. If oversampling is used, a
  resampler is used. Depending on the browser engine, different resampling
  techniques can be used (FIR, linear, etc.).</dd>
  <dt>Memory</dt>
  <dd>This node is making a copy of the curve, so it can be quite expensive in
  terms of memory.</dd>
  <dt>Latency</dt>
  <dd>This node does not add latency if oversampling is not used. If
  over-sampling is used, and depending on the resampling technique, latency can
  be added by the processing.</dd>
  <dt>Tail</dt>
  <dd>Similarly, depending on the resampling technique used, and when using
  over-sampling, a tail can be present.</dd>
  </dl>
  <h4> PannerNode, when <code>panningModel == "HRTF"</code> </h4>
  <dl>
    <dt>CPU</dt>
    <dd><strong>Very</strong> expensive. This node is constantly doing
    convolutions between the input data and a set of HRTF impulse, that are
    characteristic of the elevation and azimuth. Additionaly, when the position
    changes, it interpolates (cross-fades) between the old and new position, so
    that the transition between two HRTF impulses is smooth. This means that for
    a stereo source, and while moving, there can be four convolver processing at
    once. Additionaly, the HRTF panning needs short delay lines.</dd>
    <dt>Memory</dt>
    <dd>The HRTF panner needs to load a set of HRTF impulses around when
    operating. Gecko loads the HRTF database only if needed, while other engines
    load it unconditionally. The convolver and delay lines require memory as
    well, depending on the Fast Fourier Transform implementation used.</dd>
    <dt>Latency</dt>
    <dd>HRTF always adds some amount of delay, but the amount depends on the
    azimuth and elevation.</dd>
    <dt>Tail</dt>
    <dd>Similarly, depending on the azimuth and elevation, a tail of different
    duration is present.</dd>
  </dl>
  <h4> PannerNode, when <code>panningModel == "equalpower"</code> </h4>
  <dl>
    <dt>CPU</dt>
    <dd>Rather cheap. The processing has two parts:
    <ul>
      <li>
        First, the azimuth needs to be determined from the Cartesian coordinate
        of the source and listener, this is a bit of vector maths, and can be
        cached by the implementation for static sources.
      </li>
      <li>
        Then, gain is applied, maybe blending the two channels is the source is
        stereo.
      </li>
  </ul> </dd>
    <dt>Memory</dt>
    <dd>The processing being stateless, this has no memory cost.</dd>
  </dl>
  <h4> StereoPannerNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>Similar to the <code>"equalpower"</code> panning, but the azimuth is
    cheaper to compute since there is no need to do the vector math, we already
    have the position.  </dd>
    <dt>Memory</dt>
    <dd>Stateless processing, no memory cost.</dd>
  </dl>
  <h4> ConvolverNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>Very expensive, and depending on the duration of the convolution
    impulse. A background thread is used to offload some of the processing, but
    computational burst can occur in some browsers. Basically, multiple FFT are
    computed for each block.</dd>
    <dt>Memory</dt>
    <dd>The node is making a copy of the buffer for internal use, so it's taking
    a fair bit or memory (depending on the duration of the impulse).
    Additionaly, some memory can be used for the Fast Fourier Transform
    implementation, depending on the platform.
    </dd>
    <dt>Latency</dt>
    <dd>Convolver can be used to create delay-like effect, so latency can
    certainly be introduced by a <code>ConvolverNode</code>.</dd>
    <dt>Tail</dt>
    <dd>Depending on the convolution impulse, there can be a tail.</dd>
  </dl>
  <h4> ChannelSplitterNode / ChannelMergerNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>This is merely splitting or merging channels, that is copying buffer
    around.
    </dd>
    <dt>Memory</dt>
    <dd>No memory implications</dd>
  </dl>
  <h4> DynamicsCompressorNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>The exact algorithm is not specified yet. In practice, it's the same in
    all browsers, a peak detecting look-ahead, with a pre-emphasis and
    post-de-emphasis, not too expensive.</dd>
    <dt>Memory</dt>
    <dd>Not very expensive in terms of memory, just some </dd>
    <dt>Latency</dt>
    <dd>Being a look ahead compressor, it introduces a fixed look-ahead of
    six milliseconds.</dd>
    <dt>Tail</dt>
    <dd>Because of the emphasis, there is a tail. Also, compression can boost
    quiet audio, so audible sound can appear to last longer.</dd>
  </dl>
  <h4> OscillatorNode </h4>
  <dl>
    <dt>CPU</dt>
    <dd>The basic wave forms are implemented using multiple wave tables computed
    using the inverse Fourier transform of a buffer with carefully chosen
    coefficients (apart from the sine that is computed directly in Gecko). This
    means that there is an initial cost when changing the wave form, that is
    cached in Gecko-based browser. After the initial cost, processing is
    essentially doing linear interpolation between multiple wave tables. When
    the frequency changes, new tables have to be computed.
    </dd>
    <dt>Memory</dt>
    <dd>A number of wave tables have to be stored, that can take up some memory.
    Those are shared in Gecko-based browsers, apart from the sine wave in Gecko,
    that is directly computed.</dd>
  </dl>
  <h3> Other noteworthy performance characteristics </h3>
  <h4> Memory model </h4>

  Web Audio API implementation use two threads. The <em>control thread</em> is
  the thread on which are issued the Web Audio API calls:
  <code>createGain</code>, <code>setTargetAtTime</code>, etc. The <em>rendering
  thread</em> is the thread that is responsible for rendering the audio. This
  can be a normal thread (for example for an <code>OfflineAudioContext</code>) or a
  system provided, high-priority audio thread (for a normal
  <code>AudioContext</code>). Of course, informations have to be communicated
  between the two threads.

  Current Web Audio API implementations have taken two different approaches to
  implement the specification. Gecko-based browsers use an <em>message
  passing</em> model, whereas all the other implementation use a <em>shared
  memory</em> model. This has a number of implications in practice.

  First, in engines that are using the <em>shared memory</em> model, changes to
  the graph and <code>AudioParam</code> can occur at any time. This means that
  in some scenario, manipulation (from the main thread) of internal Web Audio
  API data structures can be reflected more quickly in the rendering thread. For
  example, if the audio thread is current rendering, a modification from the
  main thread will be reflected immediately on the rendering thread.

  A drawback of this approach is that it is necessary to have some
  synchronization between the control thread  and the rendering thread. The
  rendering thread is often very high priority (usually the highest priority on
  the system), to guarantee no under-runs (or dropouts), which are considered
  catastrophic failures, for most audio rendering system. Under-runs usually
  occur when the audio rendering thread did not make its deadline. For example,
  it took more than 5 milliseconds of processing to process 5 milliseconds of
  audio. Non-Gecko based browers are often using <em>try locks</em> to ensure
  smooth operation.

  In certain parts of the Web Audio API, there is a need to a be able to access
  data structure sent to the rendering thread, from the main thread. Gecko-based
  browsers keep two synchronized copies of the data structure to implement this,
  this has a cost in memory, that other engines don't have to pay.

  <h4> AudioParam </h4>
  The way a web application uses <code>AudioParam</code> plays an important role
  in the performance of the application. <code>AudioParam</code> come in two
  flavours, <em>a-rate</em> and <em>k-rate</em> parameters. <em>a-rate</em>
  parameters have their value computed for each audio sample, whereas
  <em>k-rate</em> parameters are computed once per 128 frames block.

  <code>AudioParam</code> methods (<code>setValueAtTime</code>,
  <code>linearRampToValueAtTime</code>, etc.) each insert <em>events</em> in a
  list of events that is later accessed by the rendering thread.

  Handling <code>AudioParam</code>, for an engine, means first finding the right
  event (or events) to consider for the block of audio to render. Different
  approaches are taken by different browsers. Gecko prefers to prune all events
  that are in the past but the one that is right before the current time
  (certain events require to have a look at the previous event's value). This
  guarantees amortized <em>O(1)</em> complexity (amortized because deallocations
  can take some time). Other engines do a linear scan in the event list to find
  the right one.

  In practice, both techniques perform well enough so that the difference is not
  noticeable most of the time. If the application uses <em>a lot </em> of
  <code>AudioParam</code> events, non-Gecko based browers can have performance
  issues, because scanning through the list starts to take a non-trivial amount
  of time. Strategies can be employed to mitigate this issue, by creating new
  <code>AudioNode</code>, with new <code>AudioParam</code>, that start with an
  empty list of events.

  For example, let's take a <code>GainNode</code> that is used as the envelope
  of an <code>OscillatorNode</code>-based kick drum, playing each beat at 140
  beat per minute. The envelope is often implemented using a
  <code>setValueAtTime</code> call to set the initial volume of the hit, that
  often depends on the velocity, immediately followed by a
  <code>setTargetAtTime</code> call, at the same time, with a value of 0 to have
  a curve that decays to silence, and a time constant that depends on the
  release parameter of the synth. At 140BPM, 280 events will be inserted by
  minute. To ensure stable performance, and leveraging the fact that a
  <code>GainNode</code> is very cheap to create and connect, it might be worth
  it to consider swapping the node that is responsible for the envelope
  regularly.

  Gecko-based browers, because of their event-loop based model, have two copies
  of the event list. One on the main thread, that contains all the events, and
  one on the rendering thread, that is regularly pruned to only contain relevant
  events. Other engines simply synchronize the event list using a lock, and only
  have one copy of the event list. Depending on how the application schedules
  its <code>AudioParam</code> events (the worst case being when all the events
  are scheduled in advance), having two copies of the event list can take a
  non-negligible amount of memory.

  The second part of <em>AudioParam</em> handling is computing the actual value
  (or value, for an <em>a-rate</em> parameter, based on past, present and future
  events. Gecko-based browsers are not very efficient are computing those values
  (and suffer from a number of bugs in the implementation). This code is going
  to go through a rewrite <em>real soon (tm)</em>. Other engines are much more
  efficient (which, most of the time, offsets their less efficient way of
  searching for the right events to consider). Blink even has optimized code to
  compute the automation curves, using SSE intrinsics on x86.

  All that said, and while implementations are becoming more and more efficient
  at computing automation curves, it is event more efficient to not use
  <code>AudioParam</code> if not necessary, implementation often take different
  code path if they know an <code>AudioParam</code> value is going to be
  constant for a block.

  <h4> Node ordering </h4>
  <h4> Latency </h4>
  <h4> Browser architecture </h4>
</section>
<section>
  <h2>Using lighter processing</h2>
  <h3>Built-in resampling</h3>
  <h3>Asset pre-baking</h3>
  <h3>Cheaper reverb</h3>
  <h3>Cheaper panning</h3>
</section>
<section>
  <h2>Debugging Web Audio API applications</h2>
  <h3>Node Wrapping</h3>
  <h3>Firefox' Web Audio API debugger</h3>
</section>
<div data-fill-with="conformance">
</div>
</body>
</html>
