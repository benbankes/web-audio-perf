<!doctype html><html lang="en">
 <head>
  <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
  <title>Web Audio API performance and debugging notes</title>
  <meta content="width=device-width, initial-scale=1, shrink-to-fit=no" name="viewport">
  <meta content="ED" name="w3c-status">
  <link href="../default.css" rel="stylesheet" type="text/css">
  <link href="../csslogo.ico" rel="shortcut icon" type="image/x-icon">
  <link href="https://www.w3.org/StyleSheets/TR/2016/W3C-ED" rel="stylesheet" type="text/css">
<style>
body.h-entry {
  background-image:none !important;
}
  </style>
  <meta content="Bikeshed 1.0.0" name="generator">
 <body class="h-entry">
  <div class="head">
   <p data-fill-with="logo"></p>
   <h1 class="p-name no-ref" id="title">Web Audio API performance and debugging notes</h1>
   <div data-fill-with="spec-metadata">
    <dl>
     <dt>This version:
     <dd><a class="u-url" href="https://padenot.github.io/web-audio-perf">https://padenot.github.io/web-audio-perf</a>
     <dt class="editor">Editor:
     <dd class="editor p-author h-card vcard"><span class="p-name fn">Paul Adenot &lt;padenot@mozilla.com></span>
    </dl>
   </div>
   <p class="copyright" data-fill-with="copyright">
    <p xmlnsU0003Adct="http://purl.org/dc/terms/" xmlnsU0003Avcard="http://www.w3.org/2001/vcard-rdf/3.0#"> <a href="http://creativecommons.org/publicdomain/zero/1.0/" rel="license"> <img alt="CC0" src="http://i.creativecommons.org/p/zero/1.0/88x31.png" style="border-style: none;"> </a> <br> To the extent possible under law, <a href="https://padenot.github.io/web-audio-perf" rel="dct:publisher"> <span property="dct:title">Paul Adenot</span></a> has waived all copyright and related or neighboring rights to <span property="dct:title">web-audio-perf</span>.
This work is published from: <span about="https://padenot.github.io/web-audio-perf" content="FR" datatype="dct:ISO3166" property="vcard:Country"> France</span>. </p>
   </p>
   <hr title="Separator for header">
  </div>
  <h2 class="no-num no-toc no-ref heading settled" id="abstract"><span class="content">Abstract</span></h2>
  <div class="p-summary" data-fill-with="abstract">
   <p>These notes present the Web Audio API from a performance and debugging point of view, outlining some differences between implementation.</p>
  </div>
  <nav data-fill-with="table-of-contents" id="toc">
   <h2 class="no-num no-toc no-ref" id="contents">Table of Contents</h2>
   <ol class="toc" role="directory">
    <li><a href="#introduction"><span class="secno">1</span> <span class="content">Introduction</span></a>
    <li>
     <a href="#optimizating-web-audio-api-applications"><span class="secno">2</span> <span class="content">Optimizating Web Audio API applications</span></a>
     <ol class="toc">
      <li>
       <a href="#audionodes-characteristics"><span class="secno">2.1</span> <span class="content"><code>AudioNode</code>s characteristics</span></a>
       <ol class="toc">
        <li><a href="#audiobuffersourcenode"><span class="secno">2.1.1</span> <span class="content"> AudioBufferSourceNode </span></a>
        <li><a href="#scriptprocessornode"><span class="secno">2.1.2</span> <span class="content"> ScriptProcessorNode </span></a>
        <li><a href="#analysernode"><span class="secno">2.1.3</span> <span class="content"> AnalyserNode </span></a>
        <li><a href="#gainnode"><span class="secno">2.1.4</span> <span class="content"> GainNode </span></a>
        <li><a href="#delaynode"><span class="secno">2.1.5</span> <span class="content"> DelayNode </span></a>
        <li><a href="#biquadfilternode"><span class="secno">2.1.6</span> <span class="content"> BiquadFilterNode </span></a>
        <li><a href="#iirfilternode"><span class="secno">2.1.7</span> <span class="content"> IIRFilterNode </span></a>
        <li><a href="#waveshapernode"><span class="secno">2.1.8</span> <span class="content"> WaveShaperNode </span></a>
        <li><a href="#pannernode-when-panningmodel--hrtf"><span class="secno">2.1.9</span> <span class="content"> PannerNode, when <code>panningModel == "HRTF"</code> </span></a>
        <li><a href="#pannernode-when-panningmodel--equalpower"><span class="secno">2.1.10</span> <span class="content"> PannerNode, when <code>panningModel == "equalpower"</code> </span></a>
        <li><a href="#stereopannernode"><span class="secno">2.1.11</span> <span class="content"> StereoPannerNode </span></a>
        <li><a href="#convolvernode"><span class="secno">2.1.12</span> <span class="content"> ConvolverNode </span></a>
        <li><a href="#channelsplitternode-channelmergernode"><span class="secno">2.1.13</span> <span class="content"> ChannelSplitterNode / ChannelMergerNode </span></a>
        <li><a href="#dynamicscompressornode"><span class="secno">2.1.14</span> <span class="content"> DynamicsCompressorNode </span></a>
        <li><a href="#oscillatornode"><span class="secno">2.1.15</span> <span class="content"> OscillatorNode </span></a>
       </ol>
      <li>
       <a href="#other-noteworthy-performance-characteristics"><span class="secno">2.2</span> <span class="content"> Other noteworthy performance characteristics </span></a>
       <ol class="toc">
        <li><a href="#audioparam"><span class="secno">2.2.1</span> <span class="content"> AudioParam </span></a>
        <li><a href="#node-ordering"><span class="secno">2.2.2</span> <span class="content"> Node ordering </span></a>
        <li><a href="#latency"><span class="secno">2.2.3</span> <span class="content"> Latency </span></a>
        <li><a href="#memory-model"><span class="secno">2.2.4</span> <span class="content"> Memory model </span></a>
        <li><a href="#browser-architecture"><span class="secno">2.2.5</span> <span class="content"> Browser architecture </span></a>
       </ol>
     </ol>
    <li>
     <a href="#using-lighter-processing"><span class="secno">3</span> <span class="content">Using lighter processing</span></a>
     <ol class="toc">
      <li><a href="#built-in-resampling"><span class="secno">3.1</span> <span class="content">Built-in resampling</span></a>
      <li><a href="#asset-pre-baking"><span class="secno">3.2</span> <span class="content">Asset pre-baking</span></a>
      <li><a href="#cheaper-reverb"><span class="secno">3.3</span> <span class="content">Cheaper reverb</span></a>
      <li><a href="#cheaper-panning"><span class="secno">3.4</span> <span class="content">Cheaper panning</span></a>
     </ol>
    <li>
     <a href="#debugging-web-audio-api-applications"><span class="secno">4</span> <span class="content">Debugging Web Audio API applications</span></a>
     <ol class="toc">
      <li><a href="#node-wrapping"><span class="secno">4.1</span> <span class="content">Node Wrapping</span></a>
      <li><a href="#firefox-web-audio-api-debugger"><span class="secno">4.2</span> <span class="content">Firefox' Web Audio API debugger</span></a>
     </ol>
    <li><a href="#references"><span class="secno"></span> <span class="content">References</span></a>
   </ol>
  </nav>
  <main>
   <section>
    <h2 class="heading settled" data-level="1" id="introduction"><span class="secno">1. </span><span class="content">Introduction</span><a class="self-link" href="#introduction"></a></h2>
     In this tutorial, we will look at two different aspects of working with the Web
  Audio API. 
    <p>First, we’ll have a look into the performance characteristics of the different
  AudioNodes available, their performance profile, overall CPU and memory cost,
  and strategies to use resources (CPU, memory) more efficiently. For example,
  we’ll learn how to look into the source code of different implementations, and
  determine the algorithm and techniques used in each browser, to make better
  choices when developing applications.</p>
    <p>We’ll then look into ways to make processing lighter, while still retaining the
  essence of the application, for example to make a "degraded" mode for mobile.
  We’ll use techniques such as substituting rendering methods to trade fidelity
  against CPU load, pre-baking assets, minimizing resampling.</p>
    <p>Throughout the workshop, we’ll use tools and techniques to debug audio problems,
  both using in-browser tools, or JavaScript code designed to inspect static and
  dynamic audio graphs and related Web Audio API objects.</p>
   </section>
   <section>
    <h2 class="heading settled" data-level="2" id="optimizating-web-audio-api-applications"><span class="secno">2. </span><span class="content">Optimizating Web Audio API applications</span><a class="self-link" href="#optimizating-web-audio-api-applications"></a></h2>
    <h3 class="heading settled" data-level="2.1" id="audionodes-characteristics"><span class="secno">2.1. </span><span class="content"><code>AudioNode</code>s characteristics</span><a class="self-link" href="#audionodes-characteristics"></a></h3>
     This section explains the characteristics of each of the <code>AudioNode</code> that are available in the Web Audio API, from four
  angles. 
    <ul>
     <li> CPU, that is the temporal complexity of the processing algorithm; 
     <li> Memory, whether node needs to keep buffers around, or needs internal memory
  for processing; 
     <li> Latency, whether the processing induces a delay in the processing chain. If
  this section is not present, the node does not add latency; 
     <li> Tail, whether you can have a non-zero output when the
  input is continously silent (for example because the audio source has
  stopped). If this section is not present, the node does not have a tail. 
    </ul>
    <h4 class="heading settled" data-level="2.1.1" id="audiobuffersourcenode"><span class="secno">2.1.1. </span><span class="content"> AudioBufferSourceNode </span><a class="self-link" href="#audiobuffersourcenode"></a></h4>
    <dl>
     <dt>CPU
     <dd>The <code>AudioBufferSourceNode</code> automatically resamples its <code>buffer</code> attrbute to the sample-rate of the <code>AudioContext</code>. Resampling is
    done differently in different browsers. Edge, Blink and Webkit based browser
    use linear resampling, that is cheap, has no latency, but has low quality.
    Gecko based browser use a more expensive but higher quality technique, that
    introduces some latency.
     <dt>Memory
     <dd>The <code>AudioBufferSourceNode</code> reads sample from an <code>AudioBuffer</code> that can be shared between multiple nodes. The
    resampler used in Gecko uses some memory for the filter, but nothing major.
    </dl>
    <h4 class="heading settled" data-level="2.1.2" id="scriptprocessornode"><span class="secno">2.1.2. </span><span class="content"> ScriptProcessorNode </span><a class="self-link" href="#scriptprocessornode"></a></h4>
    <dl>
     <dt>CPU
     <dd>On Gecko-based browsers, this node uses a message queue to send buffers
    back and forth between the main thread and the rendering thread. On other
    browsers, buffer ping-ponging is used. This means that the former is more
    reliable against dropouts, but can have a higher latency (depending on the
    main thread event loop load), whereas the latter drops
    out more easily, but has fixed latency.
     <dt>Memory
     <dd> Buffers have to be allocated to move audio back and forth between threads.
    Since Gecko uses a buffer queue, more memory can be used. 
     <dt>Latency
     <dd> The latency is specified when creating the node. If Gecko has trouble
    keeping up, the latency will increase, up to a point where audio will start
    to drop.
    </dl>
    <h4 class="heading settled" data-level="2.1.3" id="analysernode"><span class="secno">2.1.3. </span><span class="content"> AnalyserNode </span><a class="self-link" href="#analysernode"></a></h4>
    <dl>
     <dt>CPU
     <dd>This node can give frequency domain data, using a Fast Fourier Transform
  algorithm, that is expensive to compute. The higher the buffer size, the more
  expensive the computing is. <code>byte</code> version of the analysis methods
  are not cheaper than <code>float</code> alternative, they are provided for
  convenience: the <code>byte</code> version are computed from the <code>float</code> version, using simple quantization to 2^8 values.
     <dt>Memory
     <dd>Fast Fourier Transform algorithms use internal memory for processing.
  Different platforms and browsers have different algorithms, so it’s hard to
  quantify exactly how much memory is going to be used. Additionnaly, some
  memory is going to be used for the <code>AudioBuffer</code> passed in to the
  analysis methods. 
     <dt>Latency
     <dd>Because of the windowing function there can be some perceived latency in
  this node, but windowing can be disabled by setting it to 0.
     <dt>Tail
     <dd>Because of the windowing function there can be a tail with
  this node, but windowing can be disabled by setting it to 0.
    </dl>
    <h4 class="heading settled" data-level="2.1.4" id="gainnode"><span class="secno">2.1.4. </span><span class="content"> GainNode </span><a class="self-link" href="#gainnode"></a></h4>
    <dl>
     <dt>CPU
     <dd>Gecko-based browsers, the gain is always applied lazily, and folded in
    before processing that require to touch the samples, or before send the
    rendered buffer back to the operating system, so <code>GainNode</code> with
    a fixed gain are essentially free. In other UAs, the gain is applied to the
    input buffer as it’s received. When automating the gain using <code>AudioParam</code> methods, the gain is applied to the buffer in all
    browsers. 
     <dt>Memory
     <dd>A <code>GainNode</code> is stateless and has therefore no associated
    memory cost.
    </dl>
    <h4 class="heading settled" data-level="2.1.5" id="delaynode"><span class="secno">2.1.5. </span><span class="content"> DelayNode </span><a class="self-link" href="#delaynode"></a></h4>
    <dl>
     <dt>CPU
     <dd>This node essentially copies input data into a buffer, and reads from this
    buffer at a different location to compute its output buffer.
     <dt> Memory
     <dd> The memory cost is a function of the number of input and output
    channels and the length of the delay line. 
     <dt>Latency
     <dd>Obviously this node introduces latency, but no more than the latency set
    by its parameter
     <dt>Tail
     <dd>This node is being keps around (not collected) until it has finished
    reading and outputing all of its internal buffer.
    </dl>
    <h4 class="heading settled" data-level="2.1.6" id="biquadfilternode"><span class="secno">2.1.6. </span><span class="content"> BiquadFilterNode </span><a class="self-link" href="#biquadfilternode"></a></h4>
    <dl>
     <dt>CPU
     <dd>Biquad filters are relatively cheap (five multiplication and four
    additions per sample).
     <dt>Memory
     <dd>Very cheap, four float for the memory of the filter.
     <dt>Latency
     <dd>Exactly two frames of latency, due to how the filter works.
     <dt>Tail
     <dd>Variable tail, depending on the filter setting (in particular the
  resonnance).
    </dl>
    <h4 class="heading settled" data-level="2.1.7" id="iirfilternode"><span class="secno">2.1.7. </span><span class="content"> IIRFilterNode </span><a class="self-link" href="#iirfilternode"></a></h4>
    <dl>
     <dt>CPU
     <dd>Similarly to the biquad filter, they are rather cheap. The complexity
   depends on the number of coefficients, that is set at construction.
     <dt>Memory
     <dd>Again, the memory usage depends on the number of coefficients, but is
   overall very small (a couple floats per coefficients).
     <dt>Latency
     <dd>A frame per coefficient.
     <dt>Tail
     <dd>Variable, depending on the value of the coefficients.
    </dl>
    <h4 class="heading settled" data-level="2.1.8" id="waveshapernode"><span class="secno">2.1.8. </span><span class="content"> WaveShaperNode </span><a class="self-link" href="#waveshapernode"></a></h4>
    <dl>
     <dt>CPU
     <dd>The computational complexity depends on the oversampling. If no
  oversampling is used, a sample is read in the wave table, using linear
  interpolation, which is a cheap process in itself. If oversampling is used, a
  resampler is used. Depending on the UA, different resampling techniques can be
  used (FIR, linear, etc.).
     <dt>Memory
     <dd>This node is making a copy of the curve, so it can be quite expensive in
  terms of memory.
     <dt>Latency
     <dd>This node does not add latency if oversampling is not used. If
  over-sampling is used, and depending on the resampling technique, latency can
  be added by the processing.
     <dt>Tail
     <dd>Similarly, depending on the resampling technique used, and when using
  over-sampling, a tail can be present.
    </dl>
    <h4 class="heading settled" data-level="2.1.9" id="pannernode-when-panningmodel--hrtf"><span class="secno">2.1.9. </span><span class="content"> PannerNode, when <code>panningModel == "HRTF"</code> </span><a class="self-link" href="#pannernode-when-panningmodel--hrtf"></a></h4>
    <dl>
     <dt>CPU
     <dd><strong>Very</strong> expensive. This node is constantly doing
    convolutions between the input data and a set of HRTF impulse, that are
    characteristic of the elevation and azimuth. Additionaly, when the position
    changes, it interpolates (cross-fades) between the old and new position, so
    that the transition between two HRTF impulses is smooth. This means that for
    a stereo source, and while moving, there can be four convolver processing at
    once. Additionaly, the HRTF panning needs short delay lines.
     <dt>Memory
     <dd>The HRTF panner needs to load a set of HRTF impulses around when
    operating. Gecko loads the HRTF database only if needed, while other UAs
    load it unconditionally. The convolver and delay lines require memory as
    well, depending on the Fast Fourier Transform implementation used.
     <dt>Latency
     <dd>HRTF always adds some amount of delay, but the amount depends on the
    azimuth and elevation.
     <dt>Tail
     <dd>Similarly, depending on the azimuth and elevation, a tail of different
    duration is present.
    </dl>
    <h4 class="heading settled" data-level="2.1.10" id="pannernode-when-panningmodel--equalpower"><span class="secno">2.1.10. </span><span class="content"> PannerNode, when <code>panningModel == "equalpower"</code> </span><a class="self-link" href="#pannernode-when-panningmodel--equalpower"></a></h4>
    <dl>
     <dt>CPU
     <dd>
      Rather cheap. The processing has two parts: 
      <ul>
       <li> First, the azimuth needs to be determined from the cartesian coordinate
        of the source and listener, this is a bit of vector maths, and can be
        cached by the implementation for static sources. 
       <li> Then, gain is applied, maybe blending the two channels is the source is
        stereo. 
      </ul>
     <dt>Memory
     <dd>The processing being stateless, this has no memory cost.
    </dl>
    <h4 class="heading settled" data-level="2.1.11" id="stereopannernode"><span class="secno">2.1.11. </span><span class="content"> StereoPannerNode </span><a class="self-link" href="#stereopannernode"></a></h4>
    <dl>
     <dt>CPU
     <dd>Similar to the <code>"equalpower"</code> panning, but the azimut is
    cheaper to compute since there is no need to do the vector math, we already
    have the position. 
     <dt>Memory
     <dd>Stateless processing, no memory cost.
    </dl>
    <h4 class="heading settled" data-level="2.1.12" id="convolvernode"><span class="secno">2.1.12. </span><span class="content"> ConvolverNode </span><a class="self-link" href="#convolvernode"></a></h4>
    <dl>
     <dt>CPU
     <dd>Very expensive, and depending on the duration of the convolution
    impulse. A background thread is used to offload some of the processing, but
    computational burst can occur in some browsers. Basically, multiple FFT are
    computed for each block.
     <dt>Memory
     <dd>The node is making a copy of the buffer for internal use, so it’s taking
    a fair bit or memory (depending on the duration of the impulse).
    Additionaly, some memory can be used for the Fast Fourier Transform
    implementation, depending on the platform. 
     <dt>Latency
     <dd>Convolver can be used to create delay-like effect, so latency can
    certainly be introduced by a <code>ConvolverNode</code>.
     <dt>Tail
     <dd>Depending on the convolution impulse, there can be a tail.
    </dl>
    <h4 class="heading settled" data-level="2.1.13" id="channelsplitternode-channelmergernode"><span class="secno">2.1.13. </span><span class="content"> ChannelSplitterNode / ChannelMergerNode </span><a class="self-link" href="#channelsplitternode-channelmergernode"></a></h4>
    <dl>
     <dt>CPU
     <dd>This is merely splitting or merging channels, that is copying buffer
    around. 
     <dt>Memory
     <dd>No memory implications
    </dl>
    <h4 class="heading settled" data-level="2.1.14" id="dynamicscompressornode"><span class="secno">2.1.14. </span><span class="content"> DynamicsCompressorNode </span><a class="self-link" href="#dynamicscompressornode"></a></h4>
    <dl>
     <dt>CPU
     <dd>The exact algorithm is not specificed yet. In practice, it’s the same in
    all browsers, a peak detecting look-ahead, with a pre-emphasis and
    post-de-emphasis, not too expensive.
     <dt>Memory
     <dd>Not very expensive in terms of memory, just some 
     <dt>Latency
     <dd>Being a look ahead compressor, it introduces a fixed look-ahead of
    six milliseconds.
     <dt>Tail
     <dd>Because of the emphasis, there is a tail. Also, compression can boost
    quiet audio, so audible sound can appear to last longer.
    </dl>
    <h4 class="heading settled" data-level="2.1.15" id="oscillatornode"><span class="secno">2.1.15. </span><span class="content"> OscillatorNode </span><a class="self-link" href="#oscillatornode"></a></h4>
    <dl>
     <dt>CPU
     <dd>The basic wave forms are implemented using multiple wave tables computed
    using the inverse Fourier transform of a buffer with carefully chosen
    coefficients (apart from the sine that is computed directly in Gecko). This
    means that there is an initial cost when changing the wave form, that is
    cached in Gecko-based browser. After the initial cost, processing is
    essentially doing linear interpolation between multiple wave tables. When
    the frequency changes, new tables have to be computed. 
     <dt>Memory
     <dd>A number of wave tables have to be stored, that can take up some memory.
    Those are shared in Gecko-based browsers, apart from the sine wave in Gecko,
    that is directly computed.
    </dl>
    <h3 class="heading settled" data-level="2.2" id="other-noteworthy-performance-characteristics"><span class="secno">2.2. </span><span class="content"> Other noteworthy performance characteristics </span><a class="self-link" href="#other-noteworthy-performance-characteristics"></a></h3>
    <h4 class="heading settled" data-level="2.2.1" id="audioparam"><span class="secno">2.2.1. </span><span class="content"> AudioParam </span><a class="self-link" href="#audioparam"></a></h4>
    <h4 class="heading settled" data-level="2.2.2" id="node-ordering"><span class="secno">2.2.2. </span><span class="content"> Node ordering </span><a class="self-link" href="#node-ordering"></a></h4>
    <h4 class="heading settled" data-level="2.2.3" id="latency"><span class="secno">2.2.3. </span><span class="content"> Latency </span><a class="self-link" href="#latency"></a></h4>
    <h4 class="heading settled" data-level="2.2.4" id="memory-model"><span class="secno">2.2.4. </span><span class="content"> Memory model </span><a class="self-link" href="#memory-model"></a></h4>
    <h4 class="heading settled" data-level="2.2.5" id="browser-architecture"><span class="secno">2.2.5. </span><span class="content"> Browser architecture </span><a class="self-link" href="#browser-architecture"></a></h4>
   </section>
   <section>
    <h2 class="heading settled" data-level="3" id="using-lighter-processing"><span class="secno">3. </span><span class="content">Using lighter processing</span><a class="self-link" href="#using-lighter-processing"></a></h2>
    <h3 class="heading settled" data-level="3.1" id="built-in-resampling"><span class="secno">3.1. </span><span class="content">Built-in resampling</span><a class="self-link" href="#built-in-resampling"></a></h3>
    <h3 class="heading settled" data-level="3.2" id="asset-pre-baking"><span class="secno">3.2. </span><span class="content">Asset pre-baking</span><a class="self-link" href="#asset-pre-baking"></a></h3>
    <h3 class="heading settled" data-level="3.3" id="cheaper-reverb"><span class="secno">3.3. </span><span class="content">Cheaper reverb</span><a class="self-link" href="#cheaper-reverb"></a></h3>
    <h3 class="heading settled" data-level="3.4" id="cheaper-panning"><span class="secno">3.4. </span><span class="content">Cheaper panning</span><a class="self-link" href="#cheaper-panning"></a></h3>
   </section>
   <section>
    <h2 class="heading settled" data-level="4" id="debugging-web-audio-api-applications"><span class="secno">4. </span><span class="content">Debugging Web Audio API applications</span><a class="self-link" href="#debugging-web-audio-api-applications"></a></h2>
    <h3 class="heading settled" data-level="4.1" id="node-wrapping"><span class="secno">4.1. </span><span class="content">Node Wrapping</span><a class="self-link" href="#node-wrapping"></a></h3>
    <h3 class="heading settled" data-level="4.2" id="firefox-web-audio-api-debugger"><span class="secno">4.2. </span><span class="content">Firefox' Web Audio API debugger</span><a class="self-link" href="#firefox-web-audio-api-debugger"></a></h3>
   </section>
   <div data-fill-with="conformance"></div>
  </main>
  <h2 class="no-num no-ref heading settled" id="references"><span class="content">References</span><a class="self-link" href="#references"></a></h2>